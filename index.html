<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Discover - Unfiltered LPs</title>
    <style>
        body { font-family: Arial, sans-serif; background: #111; color: #eee; margin: 0; padding: 20px; }
        .header { display: flex; flex-wrap: wrap; gap: 15px; align-items: center; margin-bottom: 20px; }
        h1 { margin: 0; font-size: 24px; }
        .search-bar { padding: 10px; width: 300px; background: #333; border: none; border-radius: 4px; color: white; }
        .filters select { padding: 8px; background: #333; color: white; border: 1px solid #555; border-radius: 4px; }
        table { width: 100%; border-collapse: collapse; background: #222; font-size: 14px; overflow-x: auto; display: block; white-space: nowrap; }
        th, td { padding: 10px 12px; border-bottom: 1px solid #444; text-align: right; }
        th { background: #333; cursor: pointer; user-select: none; }
        th:first-child, td:first-child { text-align: left; }
        .pair-cell { display: flex; align-items: center; gap: 10px; }
        .mini-chart { width: 110px; height: 36px; background: #222; border: 1px solid #444; border-radius: 2px; position: relative; overflow: hidden; }
        .star { cursor: pointer; font-size: 18px; }
        .simulate { background: #0066ff; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 12px; }
        .positive { color: #00ff88; }
        .sort-asc::after { content: " ↑"; color: #00ff88; }
        .sort-desc::after { content: " ↓"; color: #ff6666; }
        .loading { color: #888; text-align: center; padding: 20px; }
        .error { color: #ff4444; }
    </style>
</head>
<body>
    <div class="header">
        <h1>Discover - Unfiltered Liquidity Pools</h1>
        <input type="text" class="search-bar" placeholder="Search pair..." id="searchInput">
        <div class="filters">
            <select id="dexFilter"></select>
            <select id="chainFilter"></select>
            <select id="timeFilter">
                <option>30 Days</option>
                <option>7 Days</option>
                <option>24 Hours</option>
            </select>
        </div>
    </div>

    <table>
        <thead>
            <tr>
                <th onclick="sortTable(0)">Pair</th>
                <th onclick="sortTable(1)">Age</th>
                <th onclick="sortTable(2)">TVL</th>
                <th onclick="sortTable(3)">Fees (24h)</th>
                <th onclick="sortTable(4)">Fee/TVL</th>
                <th class="positive" onclick="sortTable(5)">APR (Adj. IL)</th>
                <th onclick="sortTable(6)">Volatility</th>
                <th onclick="sortTable(7)">Correlation</th>
                <th onclick="sortTable(8)">Rewards/TVL</th>
                <th onclick="sortTable(9)">Volume/TVL</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody id="poolsBody"><tr class="loading"><td colspan="11">Loading live data...</td></tr></tbody>
    </table>

    <script>
        // REPLACE WITH YOUR KEYS (free signups)
        const GECKO_API_KEY = ''; // GeckoTerminal (optional for basic)
        const MORALIS_API_KEY = ''; // Moralis for Pump.fun
        const METEORA_API = 'https://api.meteora.ag/pair/all'; // Public

        // DEX list (sorted by DeFiLlama TVL)
        const dexList = ["Uniswap", "PancakeSwap", "Raydium", "Orca", "SushiSwap", "Aerodrome", "Velodrome", "QuickSwap", "Meteora", "Pump.fun", "HyperSwap", "ProjectX", "Shadow"];
        const dexChainMap = {"Uniswap":"eth","PancakeSwap":"bsc","Raydium":"solana","Orca":"solana","SushiSwap":"eth","Aerodrome":"base","Velodrome":"optimism","QuickSwap":"polygon","Meteora":"solana","Pump.fun":"solana","HyperSwap":"hyperliquid","ProjectX":"hyperliquid","Shadow":"sonic"}; // Gecko network IDs

        // Fill dropdowns
        const dexSelect = document.getElementById("dexFilter");
        dexList.forEach(dex => dexSelect.add(new Option(dex, dex)));
        dexSelect.value = "Uniswap";

        const chains = [...new Set(Object.values(dexChainMap))].map(c => c === 'bsc' ? 'BNB Chain' : c === 'eth' ? 'Ethereum' : c.charAt(0).toUpperCase() + c.slice(1));
        const chainSelect = document.getElementById("chainFilter");
        chains.forEach(c => chainSelect.add(new Option(c, c)));

        dexSelect.onchange = function() {
            chainSelect.value = dexChainMap[this.value];
            loadPools();
        };
        chainSelect.onchange = loadPools;

        let pools = [];
        async function loadPools() {
            const tbody = document.getElementById("poolsBody");
            tbody.innerHTML = '<tr class="loading"><td colspan="11">Loading live pools...</td></tr>';

            const dex = dexSelect.value;
            const chain = dexChainMap[dex];
            let apiPools = [];

            if (dex === "Meteora") {
                // Meteora specific
                try {
                    const res = await fetch(METEORA_API);
                    const data = await res.json();
                    apiPools = data.slice(0, 20); // Top 20
                } catch (e) {
                    tbody.innerHTML = '<tr class="error"><td colspan="11">Error loading Meteora data</td></tr>';
                    return;
                }
            } else if (dex === "Pump.fun") {
                // Moralis for Pump.fun new pools
                try {
                    const res = await fetch(`https://solana-gateway.moralis.io/token/mainnet/new?chain=solana&limit=20`, {
                        headers: { 'X-API-Key': MORALIS_API_KEY }
                    });
                    const data = await res.json();
                    apiPools = data.result;
                } catch (e) {
                    tbody.innerHTML = '<tr class="error"><td colspan="11">Error loading Pump.fun data (check Moralis key)</td></tr>';
                    return;
                }
            } else {
                // GeckoTerminal for others
                try {
                    const res = await fetch(`https://api.geckoterminal.com/api/v2/networks/${chain}/pools?include=base_token,quote_token&sort=reserve_in_usd_desc&limit=20`, {
                        headers: GECKO_API_KEY ? { 'Authorization': `Bearer ${GECKO_API_KEY}` } : {}
                    });
                    const data = await res.json();
                    apiPools = data.data;
                } catch (e) {
                    tbody.innerHTML = '<tr class="error"><td colspan="11">Error loading GeckoTerminal data (check key)</td></tr>';
                    return;
                }
            }

            pools = await Promise.all(apiPools.map(async (pool) => {
                const base = pool.attributes.base_token_symbol;
                const quote = pool.attributes.quote_token_symbol;
                const tvl = pool.attributes.reserve_in_usd;
                const fees24h = pool.attributes.h24_volume_usd * (dex === "Uniswap" ? 0.003 : 0.0025); // Avg fee tier
                const feeTvl = (fees24h / tvl) * 100;
                const age = new Date(pool.attributes.created_at).toLocaleDateString(); // Simplified

                // OHLCV for volatility/correlation/drawdown
                let priceData = [];
                try {
                    const ohlcvRes = await fetch(`https://api.geckoterminal.com/api/v2/networks/${chain}/pools/${pool.attributes.network.address}/ohlcv/minute?aggregated=false&limit=30`);
                    const ohlcvData = await ohlcvRes.json();
                    priceData = ohlcvData.data.map(d => d.attributes.close);
                } catch (e) {
                    priceData = Array(30).fill(100); // Fallback
                }
                const maxP = Math.max(...priceData), minP = Math.min(...priceData);
                const drawdown = (maxP - minP) / maxP;
                const adjApr = (feeTvl * (1 - drawdown)).toFixed(2);
                const volatility = (priceData.reduce((a,b)=>a+Math.pow(b-Math.mean(priceData),2),0)/priceData.length).toFixed(2); // Std dev
                const correlation = 0.7; // Placeholder - compute Pearson from pair assets if time
                const rewardsTvl = 0; // From farm APIs if needed
                const volTvl = (pool.attributes.h24_volume_usd / tvl * 100).toFixed(2);

                return { pair: `${base}/${quote}`, age, tvl, fees24h, feeTvl, adjApr, volatility, correlation, rewardsTvl, volTvl, priceData };
            }));

            render();
        }

        function render() {
            const tbody = document.getElementById("poolsBody");
            tbody.innerHTML = "";
            pools.forEach((p, i) => {
                const row = document.createElement("tr");
                row.innerHTML = `
                    <td class="pair-cell"><span class="star">⭐</span> ${p.pair} <div class="mini-chart"></div></td>
                    <td>${p.age}</td>
                    <td>$${p.tvl.toLocaleString()}</td>
                    <td>$${p.fees24h.toLocaleString()}</td>
                    <td>${p.feeTvl.toFixed(2)}%</td>
                    <td class="positive">${p.adjApr}%</td>
                    <td>${p.volatility}</td>
                    <td>${p.correlation}</td>
                    <td>${p.rewardsTvl}%</td>
                    <td>${p.volTvl}%</td>
                    <td><button class="simulate">Simulate</button></td>`;
                tbody.appendChild(row);
                drawChart(row.querySelector(".mini-chart"), p.priceData, p.adjApr < 5 ? -1 : p.adjApr > 10 ? 1 : 0); // Trend based on APR
            });
        }

        // SVG chart
        function drawChart(element, data, trend) {
            const color = trend === -1 ? "#ff4444" : trend === 1 ? "#00ff88" : "#ffaa00";
            const min = Math.min(...data), max = Math.max(...data);
            const points = data.map((v, i) => `${i * 110 / 29},${36 - (v - min) / (max - min) * 34}`).join(" ");
            element.innerHTML = `<svg width="110" height="36"><polyline fill="none" stroke="${color}" stroke-width="2" points="${points}"/></svg>`;
        }

        // Sorting (same as before)
        let sortDir = {};
        function sortTable(col) {
            const keys = ["pair", "age", "tvl", "fees24h", "feeTvl", "adjApr", "volatility", "correlation", "rewardsTvl", "volTvl"];
            const key = keys[col];
            if (!key) return;
            const dir = sortDir[col] === 'asc' ? 'desc' : 'asc';
            sortDir[col] = dir;
            pools.sort((a, b) => {
                let x = a[key], y = b[key];
                if (typeof x === "string") x = x.toLowerCase(), y = y.toLowerCase();
                else x = parseFloat(x) || 0, y = parseFloat(y) || 0;
                return dir === 'asc' ? (x > y ? 1 : x < y ? -1 : 0) : (x < y ? 1 : x > y ? -1 : 0);
            });
            document.querySelectorAll("th").forEach((th, i) => {
                th.className = i === col ? (dir === 'asc' ? "sort-asc" : "sort-desc") : "";
            });
            render();
        }

        // Listeners
        document.getElementById("searchInput").oninput = applyFilters; // Filter on search
        document.getElementById("timeFilter").onchange = loadPools; // Reload for timeframe (OHLCV adjust)

        // Initial load
        loadPools();
    </script>
</body>
</html>
